---
id: durable-promise
title: Durable Promises
sidebar_label: Durable Promises
last_update:
  date: "08-23-2024"
tags:
  - concepts
  - durable-promises
---

**What is a Durable Promise?**

Durable promises are like regular promises but they persist in storage as a [REST resource](https://www.w3schools.in/restful-web-services/rest-resources#:~:text=What%20is%20The%20REST%20Resources,Text%20Files%2C%20Videos%2C%20etc.).
They have a unique identity that lives beyond the execution of the underlying function.
By doing this, if something goes wrong (like a power outage or network hiccup), the application can look back at the saved results, quickly skip to where it left off, and keep going as if nothing ever happened, making your application resilient to unexpected failures and gracefully recover.

## Storage

**Where are Durable Promises stored?**

There are two places where a Durable Promise may be stored, locally or remotely.

### Local storage

import local from "/img/local.png";

<center>
  <img src={local} alt="local" width="500" />
</center>

The local use case involves a durable promise that is both created and completed by the same process.
The primary focus is reliability, forming the bedrock for several powerful features:

- **Retries**: If a process fails while executing a durable promise due to a transient or intermittent issue, such as network connectivity problems, it can be transparently retried, minimizing the impact of temporary failures.

- **Recoverability**: If a process crashes while executing a durable promise, it can recover and continue from where it left off, ensuring your application remains resilient.

- **Schedules**: Durable promises can be used to schedule stateful reminders to run operations periodically.

### Remote storage

import remote from "/img/remote.png";

<center>
  <img src={remote} alt="remote" width="500" />
</center>

The remote use case involves a durable promise that is created by one process and completed by another distinct process. The primary purpose is to facilitate coordination between different processes or services, serving as the foundation for features like:

- **Task framework**: Durable promises allow you to distribute tasks across multiple machines for parallel execution and collect the operationsâ€™ results.

- **Notifications**: When a durable promise is created or completed, it can trigger notifications to other processes or services that are interested in the result, enabling efficient communication and coordination.

- **Human in the Loop**: Durable promises can seamlessly integrate human input into your automated workflows, allowing for manual intervention or approval steps when needed.

## Identity

In distributed async/await applications, durable promises must have a unique identifier (ID).
This ID is used to store the computational progress and final result of the execution, allowing it to resume seamlessly from where it left off if interrupted.

```ts title="purchase.ts"
// UID uniquely identifies the purchase.
const uid = `purchase/user/${user.id}/song/${song.id}`;

// Run the registered 'purchase' function with the above uid and the following function arguments.
const val = await resonate.run("purchase", uid, user, song);
```

When designing the naming scheme for your durable promise IDs, keep the following considerations in mind:

1. **Uniqueness**: The naming scheme should guarantee uniqueness to avoid conflicts between executions.
2. **Readability**: Choose a naming scheme that is easy to understand and interpret, making it easier to debug and manage executions.
3. **Relevance**: Incorporate relevant information into the naming scheme, such as the purpose or context of the execution.

:::note

If an ID is accidentally reused for a different execution, it will result in retrieving the stored result of the previous execution instead of starting a new one.
This behavior differs from regular executions and can lead to confusion if not handled properly.

:::

### Common ID naming schemes

There are several approaches to ensure your Durable Promise IDs are unique but also readable and relevant.

#### Date-Based

One very common approach is to use the date as part of the naming scheme to. For example, if you have a durable promise that fetches and aggregates news articles on a daily basis, you could include the date in the ID format to ensure uniqueness and provide clear indication of when the execution occurred.

```
news_feed_YYYY-MM-DD
```

#### Hierarchical

You can use a hierarchical naming scheme similar to file system paths to represent the identity of a durable promise. The naming scheme can include information such as the environment, service, and specific execution details. For example:

```
staging/analytics/monthly-report/2023-05
```

#### Platform-specific

If your durable promises are running on a specific platform or orchestrator, you can incorporate the platform's identity concepts into the naming scheme. For example, if you are using Kubernetes, you can include the namespace, pod, and other relevant information:

```
k8s/staging/namespace/analytics/gpu/h100/monthly-report-2023-05
```

#### Opaque with Metadata

In this case, the durable promise ID is a randomly generated unique identifier, and you would store the associated metadata (such as environment, service, execution details) in a separate database that can be queried using the ID.

```
executions/a7b89c3d-f012-4e78-9a7d-89a3f6b2e1c7
```
